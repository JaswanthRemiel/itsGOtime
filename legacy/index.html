<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Uptime Monitor</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: system-ui, Roboto, Arial, sans-serif; margin: 24px; color: #111 }
    h1 { margin-bottom: 8px }
    table { width: 100%; border-collapse: collapse; margin-top: 12px }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left }
    .up { color: green; font-weight: 600 }
    .down { color: red; font-weight: 700 }
    .spark { width: 160px; height: 40px; display: inline-block; vertical-align: middle }
    .meta { color: #444; margin-bottom: 8px }
  </style>
</head>
<body>
  <h1>Uptime Monitor</h1>
  <div class="meta" id="meta">loading...</div>
  <table id="tbl">
    <thead>
      <tr><th>Name</th><th>URL</th><th>Status</th><th>Last hour</th><th>Last checked</th></tr>
    </thead>
    <tbody></tbody>
  </table>

<script>
async function loadData() {
  try {
    const statusRes = await fetch('status.json');
    const status = await statusRes.json();
    let history = {};
    try {
      const histRes = await fetch('history.json');
      history = await histRes.json();
    } catch (e) {
      history = {};
    }

    document.getElementById('meta').innerText = 'Generated: ' + status.generated_at;

    const tbody = document.querySelector('#tbl tbody');
    tbody.innerHTML = '';

    for (const r of status.results) {
      const tr = document.createElement('tr');

      const nameTd = document.createElement('td');
      nameTd.innerText = r.name;

      const urlTd = document.createElement('td');
      const a = document.createElement('a');
      a.href = r.url;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      a.innerText = r.url;
      urlTd.appendChild(a);

      const statusTd = document.createElement('td');
      statusTd.innerHTML = r.up ? '<span class="up">ONLINE</span>' : '<span class="down">OFFLINE</span>';
      if (r.status && r.status !== 0) {
        statusTd.innerHTML += ' (' + r.status + ')';
      }

      const sparkTd = document.createElement('td');
      const canvas = document.createElement('canvas');
      canvas.className = 'spark';
      canvas.width = 160;
      canvas.height = 40;
      sparkTd.appendChild(canvas);

      const lastCheckedTd = document.createElement('td');
      lastCheckedTd.innerText = r.timestamp;

      tr.appendChild(nameTd);
      tr.appendChild(urlTd);
      tr.appendChild(statusTd);
      tr.appendChild(sparkTd);
      tr.appendChild(lastCheckedTd);
      tbody.appendChild(tr);

      const points = history[r.name] || [];
      drawSparkline(canvas, points);
    }
  } catch (err) {
    document.body.appendChild(document.createTextNode('failed to load data: ' + err));
  }
}

function drawSparkline(canvas, points) {
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const w = canvas.width;
  const h = canvas.height;
  const pad = 4;
  const usableW = w - pad*2;
  const usableH = h - pad*2;

  const vals = points.slice(-60).map(p => p.up ? 1 : 0);
  if (vals.length === 0) {
    ctx.fillStyle = '#ccc';
    ctx.fillRect(pad, pad, usableW, usableH);
    ctx.fillStyle = '#444';
    ctx.fillText('no data', pad+6, h/2+4);
    return;
  }

  ctx.fillStyle = '#fafafa';
  ctx.fillRect(0,0,w,h);

  ctx.strokeStyle = '#eee';
  ctx.beginPath();
  ctx.moveTo(pad, h-pad-usableH/2);
  ctx.lineTo(w-pad, h-pad-usableH/2);
  ctx.stroke();

  ctx.beginPath();
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#2196F3';
  const step = usableW / Math.max(1, vals.length - 1);
  for (let i = 0; i < vals.length; i++) {
    const x = pad + (i * step);
    const y = pad + (1 - vals[i]) * usableH;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  ctx.lineTo(pad + (vals.length-1) * step, h-pad);
  ctx.lineTo(pad, h-pad);
  ctx.closePath();
  ctx.fillStyle = 'rgba(33,150,243,0.12)';
  ctx.fill();

  const last = vals[vals.length-1];
  ctx.beginPath();
  ctx.arc(w - pad - 8, pad + 8, 6, 0, Math.PI*2);
  ctx.fillStyle = last ? 'green' : 'red';
  ctx.fill();
}

loadData();
setInterval(loadData, 30 * 1000);
</script>
</body>
</html>
